<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>就職活動メモ</title>
<style>
/* 🎨 デザインCSS - 縦並び・中央揃え・入力バグ修正版 */
:root {
  --primary-color: #007bff;
  --secondary-color: #6c757d;
  --light-bg: #f8f9fa;
  --border-color: #dee2e6;
  --header-bg: #e9ecef;
  
  --color-yellow: #fff3cd; 
  --color-green: #d4edda;
  --color-red: #f8d7da;
}
body { 
  font-family: 'Helvetica Neue', Arial, sans-serif; 
  padding: 30px; 
  background-color: var(--light-bg);
  color: #333;
  max-width: 1200px;
  margin: 0 auto;
}

h1 { 
  font-size: 28px; 
  border-bottom: 3px solid var(--primary-color);
  padding-bottom: 10px;
  margin-bottom: 30px;
  color: #212529;
  cursor: pointer; 
}
h2 {
  font-size: 20px; 
  margin-top: 30px; 
  margin-bottom: 15px; 
  font-weight: 600;
  color: var(--primary-color);
  cursor: pointer; 
}

table { 
  border-collapse: collapse; 
  margin-bottom: 25px; 
  width: 100%; 
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
  background-color: white;
  border: 1px solid var(--border-color); /* テーブル外枠は維持 */
}

/* ★★★ 縦並び風CSS: 枠線なし、中央揃え維持 ★★★ */
th, td { 
  border: none; /* セル間の枠線はなし */
  padding: 12px 15px; 
  white-space: normal;
  word-wrap: break-word;
  vertical-align: middle; 
  box-sizing: border-box; 
  text-align: center; /* ★★★ 中央揃えを維持 ★★★ */
}

th { 
  background-color: var(--header-bg); 
  font-weight: bold; 
  color: #495057; 
  position: sticky; 
  top: 0;
  z-index: 10;
  height: auto; 
  border-right: 1px solid var(--border-color); 
}
th:last-child {
  border-right: none; 
}

/* 🚩 TD共通スタイル - 縦並びの再現 */
td {
  padding: 12px 15px;
  height: auto;
  cursor: pointer; 
  transition: background-color 0.2s, box-shadow 0.1s;
  display: table-cell; 
  border-bottom: 1px solid var(--border-color); 
  border-right: 1px solid var(--border-color); 
  position: relative; /* 入力時のためにrelativeを維持 */
}
td:last-child {
  border-right: none; 
}

td.selected-cell {
    box-shadow: 0 0 0 3px var(--primary-color) inset;
    border-color: var(--primary-color) !important;
}

/* 🚩 編集用Input要素のスタイル (修正版) */
.cell-input {
  /* セル全体を覆うのではなく、セル内に収まるように調整 */
  width: 90%; 
  height: auto;
  
  /* position: absolute; を削除し、セルの内容として表示する */
  position: static; 
  display: inline-block; 
  
  box-sizing: border-box;
  border: none;
  background-color: #fffacd; 
  padding: 10px; /* パディングを少し減らしてセル内に収まりやすくする */
  font-family: inherit;
  font-size: inherit;
  text-align: center; 
  outline: 1px solid var(--primary-color);
  z-index: 20; 
}
</style>
</head>
<body>

    <h1 ondblclick="makeEditableTitle(this)">就職活動メモ</h1>

    <div class="table-container">
        <h2 ondblclick="makeEditableTitle(this)">動いている企業</h2> 
        <table id="active-companies-table">
            <thead>
                <tr>
                    <th contenteditable="true">企業名</th>
                    <th contenteditable="true">業種</th>
                    <th contenteditable="true">選考状況</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td onclick="selectCell(this)" ondblclick="makeEditable(this)"></td>
                    <td onclick="selectCell(this)" ondblclick="makeEditable(this)"></td>
                    <td onclick="selectCell(this)" ondblclick="makeEditable(this)"></td>
                </tr>
            </tbody>
        </table>
        <div class="button-group table-controls">
            <button onclick="addRow('active-companies-table')">行追加</button>
            <button onclick="deleteRow('active-companies-table')" class="secondary-btn">行削除</button>
            <button onclick="addColumn('active-companies-table')">列追加</button>
            <button onclick="deleteColumn('active-companies-table')">列削除</button>
        </div>
    </div>

    <hr>

    <div class="table-container">
        <h2 ondblclick="makeEditableTitle(this)">情報収集中企業</h2>
        <table id="research-companies-table">
            <thead>
                <tr>
                    <th contenteditable="true">企業名</th>
                    <th contenteditable="true">興味度</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td onclick="selectCell(this)" ondblclick="makeEditable(this)"></td>
                    <td onclick="selectCell(this)" ondblclick="makeEditable(this)"></td>
                </tr>
            </tbody>
        </table>
        <div class="button-group table-controls">
            <button onclick="addRow('research-companies-table')">行追加</button>
            <button onclick="deleteRow('research-companies-table')" class="secondary-btn">行削除</button>
            <button onclick="addColumn('research-companies-table')">列追加</button>
            <button onclick="deleteColumn('research-companies-table')">列削除</button>
        </div>
    </div>

    <hr>

    <div class="button-group global-controls">
        <button class="color-btn color-btn-yellow" onclick="applyColor('var(--color-yellow)')" title="イエロー">黄色</button>
        <button class="color-btn color-btn-green" onclick="applyColor('var(--color-green)')" title="グリーン">緑色</button>
        <button class="color-btn color-btn-red" onclick="applyColor('var(--color-red)')" title="レッド">赤色</button>
        <button onclick="applyColor('')" class="secondary-btn">色をクリア</button>
        
        <hr style="width: 100%; border: none; border-bottom: 1px dashed #ccc; margin: 10px 0;">

        <button onclick="saveData()">データ保存 (ブラウザ)</button>
        <button onclick="exportCSV()" class="secondary-btn">CSVとしてエクスポート</button>
        <input type="file" id="csv-file-input" accept=".csv" style="display:none;" onchange="importCSV(event)">
        <button onclick="document.getElementById('csv-file-input').click()" class="secondary-btn">CSVインポート</button>
        <button onclick="resetAll()">全リセット</button>
    </div>

<script>
let selectedCell = null;

function getTableHeadCells(tableId) {
    const table = document.getElementById(tableId);
    if (table && table.tHead && table.tHead.rows.length > 0) {
        return table.tHead.rows[0].cells;
    }
    return [];
}

// セルの内容操作は直接テキストに依存させる
function wrapContent(cell, text = '') {
    cell.innerText = text;
}

function getCellText(cell) {
    return cell.innerText;
}

function setCellText(cell, text) {
    cell.innerText = text;
}


function selectCell(cell) {
    if (cell.tagName === 'TH' || cell.querySelector('input.cell-input')) return; 

    if (selectedCell) {
        selectedCell.classList.remove('selected-cell');
    }
    
    if (selectedCell !== cell) {
        cell.classList.add('selected-cell');
        selectedCell = cell;
    } else {
        selectedCell = null;
    }
}

function applyColor(colorVariable) {
    if (!selectedCell) {
        alert("色を変更したいセルを一度クリックして選択してください。");
        return;
    }
    
    if (selectedCell.tagName === 'TH') {
        alert("項目名（ヘッダー）のセルには色を付けられません。データセルを選択してください。");
        return;
    }
    
    const color = colorVariable ? getComputedStyle(document.documentElement).getPropertyValue(colorVariable.replace('var(', '').replace(')', '')) : '';
    
    selectedCell.style.backgroundColor = color;
    
    selectedCell.classList.remove('selected-cell');
    selectedCell = null;

    alert(`セルの色を${color === '' ? 'クリア' : color}に設定しました。忘れずに「データ保存」ボタンを押してください。`);
}

// ★★★ セル編集機能のバグ修正版 ★★★
function makeEditable(cell) {
    // 既に編集中の場合は何もしない
    if (cell.querySelector('input')) return; 
    if (cell.tagName === 'TH') return; 

    if (selectedCell === cell) {
        cell.classList.remove('selected-cell');
        selectedCell = null;
    }

    const originalText = getCellText(cell);
    
    // セル内のテキストを消去し、代わりに input 要素を配置
    cell.innerText = ''; 
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'cell-input';
    input.value = originalText;
    
    input.onblur = function() {
        const newText = this.value;
        const parentCell = this.parentElement;
        
        // inputを削除し、新しいテキストをセルに戻す
        this.remove(); 
        setCellText(parentCell, newText);
    };

    input.onkeydown = function(e) {
        if (e.key === 'Enter') {
            this.blur();
        }
    };
    
    cell.appendChild(input);
    input.focus(); 
}

function getTableBody(tableId) {
    return document.getElementById(tableId).tBodies[0];
}

const decodeCSVLine = (line) => {
  const cells = line.match(/(?:"[^"]*?"|[^,]+)/g) || [];
  return cells.map(c => c.replace(/^"|"$/g,'').replace(/""/g,'"').trim());
};

function makeEditableTitle(element) {
    if (element.querySelector('input')) return;
    const originalText = element.innerText;
    element.innerText = '';
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'text-input';
    input.value = originalText;
    input.onblur = function() {
        element.innerText = this.value;
        this.remove();
    };
    input.onkeydown = function(e) {
        if (e.key === 'Enter') {
            this.blur();
        }
    };
    element.appendChild(input);
    input.focus();
}

function addRow(tableId){
  const table = document.getElementById(tableId);
  let tbody = table.tBodies[0];
  if (!tbody) { tbody = table.createTBody(); }

  const headCells = getTableHeadCells(tableId);
  const cols = headCells.length;
  
  if (cols === 0) { alert("先に列（ヘッダー）を追加してください。"); return; }

  const row = tbody.insertRow();
  
  for(let i=0; i<cols; i++){ 
    const cell=row.insertCell(); 
    cell.onclick = function() { selectCell(this); }; 
    cell.ondblclick = function() { makeEditable(this); }; 
    wrapContent(cell); 
  }
}

function deleteRow(tableId){
  const tbody = getTableBody(tableId);
  if (!tbody) return; 

  if(tbody.rows.length > 1) {
    tbody.deleteRow(-1);
  } else if (tbody.rows.length === 1) {
    Array.from(tbody.rows[0].cells).forEach(cell => {
        setCellText(cell, '');
        cell.style.backgroundColor = ''; 
    });
  }
}

function addColumn(tableId){
  const table = document.getElementById(tableId);
  let tbody = table.tBodies[0];
  if (!tbody) { tbody = table.createTBody(); }
  
  let tHeadRow;
  if (table.tHead && table.tHead.rows.length > 0) {
      tHeadRow = table.tHead.rows[0];
  } else {
      if (!table.tHead) table.createTHead();
      tHeadRow = table.tHead.insertRow();
  }
  
  const th = document.createElement('th'); 
  th.innerText = `新規項目`;
  th.contentEditable="true"; 
  tHeadRow.appendChild(th);
  
  for(let row of tbody.rows){ 
    const cell=row.insertCell(); 
    cell.onclick = function() { selectCell(this); }; 
    cell.ondblclick = function() { makeEditable(this); }; 
    wrapContent(cell);
  }
  
  if (tbody.rows.length === 0) {
      const row = tbody.insertRow();
      for (let i = 0; i < tHeadRow.cells.length; i++) {
        const cell = row.insertCell(); 
        cell.onclick = function() { selectCell(this); }; 
        cell.ondblclick = function() { makeEditable(this); }; 
        wrapContent(cell);
      }
  }
}

function deleteColumn(tableId){
  const table = document.getElementById(tableId);
  const tbody = table.tBodies[0];
  const ths = getTableHeadCells(tableId);
  
  if(ths.length > 1){ 
    ths[ths.length - 1].remove(); 
    if (tbody) {
        for(let row of tbody.rows) {
          if (row.cells.length > 0) {
            row.deleteCell(-1); 
          }
        }
    }
  } else {
      alert("最後の列は削除できません。");
  }
}

function resetAll(){
    localStorage.removeItem('tableData'); 

    document.querySelector('h1').innerText = "就職活動メモ";
    document.querySelector('.table-container:nth-of-type(1) h2').innerText = "動いている企業";
    document.querySelector('.table-container:nth-of-type(2) h2').innerText = "情報収集中企業";

    const defaultHeaders = {
        'active-companies-table': ['企業名', '業種', '選考状況'],
        'research-companies-table': ['企業名', '興味度']
    };

    ['active-companies-table','research-companies-table'].forEach(id => {
        const table = document.getElementById(id);
        
        let tHeadRow;
        if (table.tHead && table.tHead.rows.length > 0) {
            tHeadRow = table.tHead.rows[0];
        } else {
            if (!table.tHead) table.createTHead();
            tHeadRow = table.tHead.insertRow();
        }
        tHeadRow.innerHTML = '';
        defaultHeaders[id].forEach(headerText => {
            const th = document.createElement('th');
            th.contentEditable = "true";
            th.innerText = headerText;
            tHeadRow.appendChild(th);
        });
        
        let tbody = table.tBodies[0];
        if (!tbody) { tbody = table.createTBody(); }
        tbody.innerHTML = '';
        const row = tbody.insertRow();
        const headerCount = defaultHeaders[id].length;
        for (let i = 0; i < headerCount; i++) {
            const cell = row.insertCell(); 
            cell.onclick = function() { selectCell(this); }; 
            cell.ondblclick = function() { makeEditable(this); }; 
            wrapContent(cell); 
        }
    });
    alert("全データをリセットし、初期状態に戻しました。ブラウザを再起動して開くと確実です。");
}

function saveData(){
  const data={};
  data['texts']=[document.querySelector('h1').innerText, ...Array.from(document.querySelectorAll('h2')).map(h=>h.innerText)];
  
  const tableIds = ['active-companies-table', 'research-companies-table'];

  tableIds.forEach((id,index)=>{
    const table=document.getElementById(id);
    const rows=[];
    
    const headerCells = Array.from(getTableHeadCells(id)).map(cell => getCellText(cell));
    rows.push(headerCells);

    const tbody = table.tBodies[0];
    if (tbody) {
        for(let row of tbody.rows){
          const cells=[];
          const cellColors=[]; 
          for(let cell of row.cells) {
              cells.push(getCellText(cell)); 
              cellColors.push(cell.style.backgroundColor || ''); 
          }
          while (cells.length < headerCells.length) {
              cells.push('');
              cellColors.push('');
          }
          rows.push({ data: cells, colors: cellColors }); 
        }
    }
    data['table'+(index+1)]=rows; 
  });
  localStorage.setItem('tableData',JSON.stringify(data));
  alert("データをブラウザに保存しました！");
}

window.onload=()=>{
  const saved=localStorage.getItem('tableData');
  
  document.querySelector('h1').ondblclick = function() { makeEditableTitle(this); };
  document.querySelectorAll('h2').forEach(h => {
    h.ondblclick = function() { makeEditableTitle(this); };
  });

  const tableIds = ['active-companies-table', 'research-companies-table'];
  
  if(saved){
    const data=JSON.parse(saved);
    const texts=[document.querySelector('h1'), ...document.querySelectorAll('h2')];
    data.texts.forEach((txt,i)=>{ 
        if(texts[i]) texts[i].innerText=txt; 
    });
    
    tableIds.forEach((id,index)=>{
      const table=document.getElementById(id);
      
      if (!table.tHead) table.createTHead();
      if (table.tHead.rows.length === 0) table.tHead.insertRow();
      const tHeadRow=table.tHead.rows[0];
      
      let tbody = table.tBodies[0];
      if (!tbody) { tbody = table.createTBody(); }
      
      const allRows=data['table'+(index+1)]; 

      const headerData = allRows[0] || [];
      tHeadRow.innerHTML = '';
      headerData.forEach(val => {
        const th = document.createElement('th');
        th.contentEditable = "true";
        th.innerText = val;
        tHeadRow.appendChild(th);
      });

      const dataRows = allRows.slice(1);
      tbody.innerHTML = '';
      
      const headerCount = headerData.length;
      dataRows.forEach(rowDataObj => {
          const row = tbody.insertRow();
          const expectedCols = headerCount; 
          
          for (let i = 0; i < expectedCols; i++) {
              const cell = row.insertCell(); 
              cell.onclick = function() { selectCell(this); }; 
              cell.ondblclick = function() { makeEditable(this); }; 
              
              const cellVal = rowDataObj.data[i] || ''; 
              setCellText(cell, cellVal); 

              if (rowDataObj.colors && rowDataObj.colors[i]) {
                  cell.style.backgroundColor = rowDataObj.colors[i];
              }
          }
      });
    });
  }

  tableIds.forEach(id => {
    const table = document.getElementById(id);
    let tbody = table.tBodies[0];
    const headerCount = getTableHeadCells(id).length;

    if (!tbody || tbody.rows.length === 0) {
        if (!tbody) { tbody = table.createTBody(); }
        const row = tbody.insertRow();
        for (let i = 0; i < headerCount; i++) {
            const cell = row.insertCell(); 
            cell.onclick = function() { selectCell(this); }; 
            cell.ondblclick = function() { makeEditable(this); }; 
            wrapContent(cell); 
        }
    }
  });

  document.querySelectorAll('tbody td').forEach(cell => {
      cell.onclick = function() { selectCell(this); }; 
      cell.ondblclick = function() { makeEditable(this); };
      wrapContent(cell, getCellText(cell)); 
  });
}

function exportCSV(){
  let csv='"'+document.querySelector('h1').innerText.replace(/"/g,'""')+'"\n\n';
  const h2s=document.querySelectorAll('h2');
  
  h2s.forEach((h,index)=>{
    csv+='"'+h.innerText.replace(/"/g,'""')+'"\n';
    const tableId = index === 0 ? 'active-companies-table' : 'research-companies-table';
    
    if (index === 1) {
        csv += '\n'; 
    }

    const headerCells = Array.from(getTableHeadCells(tableId)).map(cell => getCellText(cell).replace(/"/g,'""'));
    csv+='"' + headerCells.join('","') + '"\n';

    const tbody = getTableBody(tableId);
    if (tbody) {
        for(let row of tbody.rows){
          let cells=[];
          for(let cell of row.cells) cells.push(getCellText(cell).replace(/"/g,'""'));
          csv+='"' + cells.join('","') + '"\n';
        }
    }
    csv+='\n';
  });
  const blob=new Blob(['\ufeff', csv],{type:'text/csv;charset=utf-8'}); 
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='job_search_memo.csv'; a.click();
}

function importCSV(event){
  const file=event.target.files[0];
  if(!file) return;
  const reader=new FileReader();
  
  reader.onload=e=>{
    const lines=e.target.result.replace(/\ufeff/g, "").split('\n').map(l=>l.trim()).filter(l=>l!=='');
    if(lines.length<1) return;
    
    let tableIndex=-1, lineIndex=1; 
    const h2s=document.querySelectorAll('h2');
    const tableIds = ['active-companies-table', 'research-companies-table'];
    
    if (lines[0]) {
        document.querySelector('h1').innerText = decodeCSVLine(lines[0])[0] || "就職活動メモ";
        lineIndex++;
    }

    while (lineIndex < lines.length && lines[lineIndex].trim() === '') {
        lineIndex++;
    }

    while(lineIndex < lines.length && tableIndex < 2){
      tableIndex++;
      const table = document.getElementById(tableIds[tableIndex]);

      if(h2s[tableIndex] && lines[lineIndex]) {
          const decodedLine = decodeCSVLine(lines[lineIndex]);
          if (decodedLine.length === 1 && decodedLine[0] !== "" && !decodedLine[0].includes(',')) {
              h2s[tableIndex].innerText = decodedLine[0];
              lineIndex++; 
          }
      }
      
      while (lineIndex < lines.length && lines[lineIndex].trim() === '') {
          lineIndex++;
      }
      
      if (!table.tHead) table.createTHead();
      if (table.tHead.rows.length === 0) table.tHead.insertRow();
      const tHeadRow = table.tHead.rows[0];
      
      let tbody = table.tBodies[0];
      if (!tbody) { tbody = table.createTBody(); }
      
      tbody.innerHTML = '';
      tHeadRow.innerHTML = '';
      
      let headerCells = [];
      if(lineIndex < lines.length && lines[lineIndex]) {
          headerCells = decodeCSVLine(lines[lineIndex]);
          headerCells.forEach(h => { 
              const th = document.createElement('th');
              th.contentEditable = "true";
              th.innerText = h;
              tHeadRow.appendChild(th);
          });
          lineIndex++; 
      }
      
      const expectedCols = tHeadRow.cells.length;

      while(lineIndex < lines.length && lines[lineIndex]){
        const rowCells = decodeCSVLine(lines[lineIndex]);
        
        if (rowCells.length === 1 && rowCells[0] !== "" && !rowCells[0].includes(',')) {
            break;
        }
        if (lines[lineIndex].trim() === '') {
            break;
        }

        const row = tbody.insertRow();
        for (let i = 0; i < expectedCols; i++) {
            const cell = row.insertCell(); 
            const cellVal = rowCells[i] ? rowCells[i] : ''; 
            
            cell.onclick = function() { selectCell(this); }; 
            cell.ondblclick = function() { makeEditable(this); }; 
            setCellText(cell, cellVal); 
        }
        lineIndex++;
      }
      
      lineIndex++; 
    }
    alert("CSVファイルをインポートしました！");
  };
  reader.readAsText(file);
}
</script>
</body>
</html>
